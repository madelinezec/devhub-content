:template: devhub-article

.. ---------------------------------------------------------------
.. META FIELDS FOR SEO / SOCIAL
.. ---------------------------------------------------------------

.. meta-description:: 

   Learn how to use the Union All ($unionWith) aggregation pipeline stage, newly released in MongoDB 4.4.

.. twitter::
   :site: @mongodb
   :creator: @adriennetacke
   :title: How to Use the Union All Aggregation Pipeline Stage in MongoDB 4.4
   :image: /images/atf-images/quickstart/aggregation-framework_ATF.png
   :image-alt: How to Use the Union All Aggregation Pipeline Stage in MongoDB 4.4

   Learn how to combine data from multiple collections with the $unionWith aggregation pipeline stage.

.. og::
   :url: http://developer.mongodb.com/how-to/use-function-accumulator-operators
   :title: How to Use the Union All Aggregation Pipeline Stage in MongoDB 4.4
   :image: /images/atf-images/quickstart/aggregation-framework_ATF.png
   :type: article

   Learn how to combine data from multiple collections with the $unionWith aggregation pipeline stage.

.. ---------------------------------------------------------------
.. ARTICLE METADATA FIELDS (TO POPULATE FILTERS AND ARTICLE PAGE)
.. ---------------------------------------------------------------

.. include:: /includes/authors/tacke-adrienne.rst

.. atf-image:: /images/atf-images/quickstart/aggregation-framework_ATF.png

.. pubdate:: 2020-08-17

.. type:: how-to

.. level:: beginner

.. tags::

   * MongoDB 4.4
   * Aggregation Framework
   * Data
   * Technical

.. products::

   * MongoDB
   * Atlas

.. ---------------------------------------------------------------
.. ARTICLE CONTENT
.. ---------------------------------------------------------------

==================================================================
How to Use the Union All Aggregation Pipeline Stage in MongoDB 4.4
==================================================================

.. introduction::
   
    With the release of MongoDB 4.4 comes a new aggregation pipeline stage called
    ``$unionWith``. This stage lets you combine multiple collections into a
    single result set!

    Here‚Äôs how you‚Äôd use it:

    **Simplified syntax, with no additional processing on the specified
    collection**

    .. code-block::

      db.collection.aggregate([
        { $unionWith: "<anotherCollection>" }
      ])

    **Extended syntax, using optional pipeline field**

    .. code-block::

      db.collection.aggregate([
        { $unionWith: { coll: "<anotherCollection>", pipeline: [ <stage1>, ... ] } }
      ])

    .. blockquote::

        ‚ö† If you use the pipeline field to process your collection before
        combining, keep in mind that stages that write data, like ``$out``
        and ``$merge``, can‚Äôt be used!

    Your resulting documents will merge your current collection‚Äôs (or
    pipeline‚Äôs) stream of documents with the documents from the
    collection/pipeline you specify. Keep in mind that this can include
    duplicates!

    This sounds kinda familiar‚Ä¶
    ---------------------------

    If you‚Äôve used the ``UNION ALL`` operation in SQL before, the
    ``$unionWith`` stage‚Äôs functionality may sound familiar to you, and you
    wouldn‚Äôt be wrong! Both combine the result sets from multiple queries
    and return the merged rows, some of which may be duplicates. However,
    that‚Äôs where the similarities end. Unlike MongoDB‚Äôs ``$unionWith``
    stage, you have to follow `a few
    rules <https://docs.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-union-transact-sql?view=sql-server-ver15>`__
    in order to run a valid ``UNION ALL`` operation in SQL:

    -  Make sure your two queries have the *same number of columns*
    -  Make sure the *order of columns* are the same
    -  Make sure the *matching columns are compatible data types*.

    It‚Äôd look something like this in SQL:

    .. code-block::

      SELECT column1, expression1, column2
      FROM table1
      UNION ALL
      SELECT column1, expression1, column2
      FROM table2
      WHERE [conditions]

    With the ``$unionWith`` stage in MongoDB, you don‚Äôt have to worry about
    these stringent constraints.

    So how is MongoDB‚Äôs ``$unionWith`` stage different?
    ---------------------------------------------------

    The most convenient difference between the ``$unionWith`` stage and
    other UNION operations is that there‚Äôs no matching schema restriction.
    This flexible schema support means you can combine documents that may
    not have the same type or number of fields. This is common in certain
    scenarios, where the data we need to use comes from different sources:

    -  TimeSeries data that‚Äôs stored by month/quarter/some other unit of time
    -  IoT device data, per fleet or version
    -  Archival and Recent data, stored in a Data Lake
    -  Regional data

    With MongoDB‚Äôs ``$unionWith`` stage, combining these data sources is
    possible.

    Ready to try the new ``$unionWith`` stage? Follow along by completing a
    few setup steps first. Or, you can `skip to the code
    samples <#examples>`__. üòâ


.. prerequisites::

   Prerequisites
   -------------

   Based on your situation, you may already have a few prerequisites setup or need to start from scratch.
   Either way, choose your scenario to configure the things you need so that you can follow
   the rest of this tutorial!

    Choose your scenario:

    **I don‚Äôt have an Atlas cluster set up yet**:

    1. You‚Äôll need an Atlas account to play around with MongoDB Atlas! `Create one <https://docs.atlas.mongodb.com/tutorial/create-atlas-account/>`__ if you haven‚Äôt already done so. Otherwise, log into your Atlas account.
    2. `Setup a free Atlas cluster <https://docs.atlas.mongodb.com/tutorial/deploy-free-tier-cluster/>`__ (no credit card needed!). Be sure to select **MongoDB 4.4** (may be Beta, which is OK) as your version in Additional Settings!

    .. blockquote::

        üí° **If you don‚Äôt see the prompt to create a cluster**: You may be
        prompted to create a project *first* before you see the prompt to
        create your first cluster. In this case, go ahead and create a
        project first (leaving all the default settings). Then continue with
        the instructions to deploy your first free cluster!

    3. Once your cluster is set up, `add your IP address <https://docs.atlas.mongodb.com/tutorial/whitelist-connection-ip-address/>`__ to your cluster‚Äôs connection settings. This tells your cluster who‚Äôs allowed to connect to it.
    4. Finally, `create a database user <https://docs.atlas.mongodb.com/tutorial/create-mongodb-user-for-cluster/>`__ for your cluster. Atlas requires anyone or anything accessing its clusters to authenticate as MongoDB database users for security purposes! Keep these credentials handy as you‚Äôll need them later on.
    5. Continue with the steps in Connecting to your cluster.

    **I have an Atlas cluster set up**:

    Great! You can skip ahead to Connecting to your cluster.

    **Connecting to your cluster**

    To connect to your cluster, we‚Äôll use the MongoDB for Visual Studio Code
    extension (VS Code for short üòä). You can view your data directly,
    interact with your collections, and much more with this helpful
    extension! Using this also consolidates our workspace into a single
    window, removing the need for us to jump back and forth between our code
    and MongoDB Atlas!

    .. blockquote::

        üí° Though we'll be using the VS Code Extension and VS Code for the rest
        of this tutorial, it's not a requirement to use the ``$unionWith`` pipeline stage!
        You can also use the `CLI <https://docs.mongodb.com/mongocli/stable/>`__, `language-specific drivers <https://docs.mongodb.com/drivers/>`__, or `Compass <https://docs.mongodb.com/compass/current/>`__ if you prefer!

    1. Install the `MongoDB for VS Code <https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode>`__ extension (or install `VS Code <https://code.visualstudio.com/Download>`__ first, if you don‚Äôt already have it üòâ).
    2. To connect to your cluster, you‚Äôll need a connection string. You can get this connection string from your cluster connection settings. Go to your cluster and select the ‚ÄúConnect‚Äù option:

      .. image:: /images/article/union-all/connect.png
         :alt: Connecting to your Atlas cluster

    3. Select the ‚ÄúConnect using MongoDB Compass‚Äù option. This will give us a connection string in the `DNS Seedlist Connection format <https://docs.mongodb.com/manual/reference/connection-string/#dns-seedlist-connection-format>`__ that we can use with the MongoDB extension.

      .. image:: /images/article/union-all/connect-with-compass.png
         :alt: Choosing the ‚ÄúConnect with MongoDB Compass‚Äù option

    .. blockquote::

        üí° The MongoDB for VS Code extension also supports the `standard
        connection string format <https://docs.mongodb.com/manual/reference/connection-string/#standard-connection-string-format>`__.
        Using the DNS seedlist connection format is purely preference.

    4. Skip to the second step and copy the connection string (don‚Äôt worry about the other settings, you won‚Äôt need them):

      .. image:: /images/article/union-all/copy-connection-string.png
         :alt: Copy the connection string in MongoDB Atlas connection settings

    5. Switch back to VS Code. Press ``Ctrl`` + ``Shift`` + ``P`` (on Windows) or ``Shift`` + ``Command`` + ``P`` (on Mac) to bring up the command palette. This shows a list of all VS Code commands.

      .. image:: /images/article/union-all/show-commands.png
         :alt: Showing the command palette in VS Code

    6. Start typing ‚ÄúMongoDB‚Äù until you see the MongoDB extension‚Äôs list of available commands. Select the ‚ÄúMongoDB: Connect with Connection String‚Ä¶‚Äù option.

      .. image:: /images/article/union-all/mdb-connect-with-connection-string.png
         :alt: Searching for MongoDB extension commands

    7. Paste in your copied connection string. üí° Don‚Äôt forget! You have to replace the placeholder password with your actual password!

      .. image:: /images/article/union-all/mdb-paste-conn-string.png
         :alt: Pasting and modifying our MongoDB Atlas cluster connection string

    8. Press enter to connect! You‚Äôll know the connection was successful if you see a confirmation message on the bottom right. You‚Äôll also see your cluster listed when you expand the MongoDB extension pane.

    With the MongoDB extension installed and your cluster connected, you can
    now use MongoDB Playgrounds to test out the ``$unionWith`` examples! MongoDB
    Playgrounds give us a nice sandbox to easily write and test Mongo
    queries. I love using it when prototying or trying something new because
    it has query auto-completion and syntax highlighting‚Ä¶something that you
    don‚Äôt get in most terminals.

.. content::

    Let‚Äôs finally dive into some examples!

    Examples
    --------

    To follow along, you can use these `MongoDB Playground files <https://github.com/adriennetacke/mdb-union-all-walkthrough>`__
    I have created to accompany this blog post or `create your own <https://docs.mongodb.com/mongodb-vscode/playgrounds>`__!

    .. blockquote::

        üí° If you create your own playground, remember to change the database
        name and delete the default template‚Äôs code first!

    ``$unionWith`` using a pipeline
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    .. blockquote::

        üìÉ Use `this <https://github.com/adriennetacke/mdb-union-all-walkthrough/blob/master/unionWith_examples_similar_schemas.mongodb>`__ playground if
        you‚Äôd like follow along with pre-written code for this example.

    Right at the top, specify the database you‚Äôll be using. In this example, I'm using a database also called ``union-walkthrough``:

    .. code-block::

      use('union-walkthrough');

    .. blockquote::

        üí° I haven't actually created a database called ``union-walkthrough`` in Atlas yet,
        but that's no problem! When the playground runs, it will see that it does not yet exist
        and create a database of the specified name!

    Next, we need data! Particularly about some planets. And particularly
    about planets in a certain movie series‚Ä¶

    Using the awesome `SWAPI API <https://swapi.dev/>`__, I‚Äôve collected
    such information on a few planets. Let‚Äôs add them into two collections,
    separated by popularity.

    Any planets that appear in at least 2 or more films are considered
    popular. Otherwise, we‚Äôll add them into the ``lonely_planets``
    collection:

    .. code-block::

      // Insert a few documents into the lonely_planets collection.
      db.lonely_planets.insertMany([
          {
              "name": "Endor",
              "rotation_period": "18",
              "orbital_period": "402",
              "diameter": "4900",
              "climate": "temperate",
              "gravity": "0.85 standard",
              "terrain": "forests, mountains, lakes",
              "surface_water": "8",
              "population": "30000000",
              "residents": [
                  "http://swapi.dev/api/people/30/"
              ],
              "films": [
                  "http://swapi.dev/api/films/3/"
              ],
              "created": "2014-12-10T11:50:29.349000Z",
              "edited": "2014-12-20T20:58:18.429000Z",
              "url": "http://swapi.dev/api/planets/7/"
          },
          {
              "name": "Kamino",
              "rotation_period": "27",
              "orbital_period": "463",
              "diameter": "19720",
              "climate": "temperate",
              "gravity": "1 standard",
              "terrain": "ocean",
              "surface_water": "100",
              "population": "1000000000",
              "residents": [
                  "http://swapi.dev/api/people/22/",
                  "http://swapi.dev/api/people/72/",
                  "http://swapi.dev/api/people/73/"
              ],
              "films": [
                  "http://swapi.dev/api/films/5/"
              ],
              "created": "2014-12-10T12:45:06.577000Z",
              "edited": "2014-12-20T20:58:18.434000Z",
              "url": "http://swapi.dev/api/planets/10/"
          },
          {
              "name": "Yavin IV",
              "rotation_period": "24",
              "orbital_period": "4818",
              "diameter": "10200",
              "climate": "temperate, tropical",
              "gravity": "1 standard",
              "terrain": "jungle, rainforests",
              "surface_water": "8",
              "population": "1000",
              "residents": [],
              "films": [
                  "http://swapi.dev/api/films/1/"
              ],
              "created": "2014-12-10T11:37:19.144000Z",
              "edited": "2014-12-20T20:58:18.421000Z",
              "url": "http://swapi.dev/api/planets/3/"
          },
          {
              "name": "Hoth",
              "rotation_period": "23",
              "orbital_period": "549",
              "diameter": "7200",
              "climate": "frozen",
              "gravity": "1.1 standard",
              "terrain": "tundra, ice caves, mountain ranges",
              "surface_water": "100",
              "population": "unknown",
              "residents": [],
              "films": [
                  "http://swapi.dev/api/films/2/"
              ],
              "created": "2014-12-10T11:39:13.934000Z",
              "edited": "2014-12-20T20:58:18.423000Z",
              "url": "http://swapi.dev/api/planets/4/"
          },
          {
              "name": "Bespin",
              "rotation_period": "12",
              "orbital_period": "5110",
              "diameter": "118000",
              "climate": "temperate",
              "gravity": "1.5 (surface), 1 standard (Cloud City)",
              "terrain": "gas giant",
              "surface_water": "0",
              "population": "6000000",
              "residents": [
                  "http://swapi.dev/api/people/26/"
              ],
              "films": [
                  "http://swapi.dev/api/films/2/"
              ],
              "created": "2014-12-10T11:43:55.240000Z",
              "edited": "2014-12-20T20:58:18.427000Z",
              "url": "http://swapi.dev/api/planets/6/"
          }
      ]);

      // Insert a few documents into the popular_planets collection.
      db.popular_planets.insertMany([
          {
              "name": "Tatooine",
              "rotation_period": "23",
              "orbital_period": "304",
              "diameter": "10465",
              "climate": "arid",
              "gravity": "1 standard",
              "terrain": "desert",
              "surface_water": "1",
              "population": "200000",
              "residents": [
                  "http://swapi.dev/api/people/1/",
                  "http://swapi.dev/api/people/2/",
                  "http://swapi.dev/api/people/4/",
                  "http://swapi.dev/api/people/6/",
                  "http://swapi.dev/api/people/7/",
                  "http://swapi.dev/api/people/8/",
                  "http://swapi.dev/api/people/9/",
                  "http://swapi.dev/api/people/11/",
                  "http://swapi.dev/api/people/43/",
                  "http://swapi.dev/api/people/62/"
              ],
              "films": [
                  "http://swapi.dev/api/films/1/",
                  "http://swapi.dev/api/films/3/",
                  "http://swapi.dev/api/films/4/",
                  "http://swapi.dev/api/films/5/",
                  "http://swapi.dev/api/films/6/"
              ],
              "created": "2014-12-09T13:50:49.641000Z",
              "edited": "2014-12-20T20:58:18.411000Z",
              "url": "http://swapi.dev/api/planets/1/"
          },
          {
              "name": "Alderaan",
              "rotation_period": "24",
              "orbital_period": "364",
              "diameter": "12500",
              "climate": "temperate",
              "gravity": "1 standard",
              "terrain": "grasslands, mountains",
              "surface_water": "40",
              "population": "2000000000",
              "residents": [
                  "http://swapi.dev/api/people/5/",
                  "http://swapi.dev/api/people/68/",
                  "http://swapi.dev/api/people/81/"
              ],
              "films": [
                  "http://swapi.dev/api/films/1/",
                  "http://swapi.dev/api/films/6/"
              ],
              "created": "2014-12-10T11:35:48.479000Z",
              "edited": "2014-12-20T20:58:18.420000Z",
              "url": "http://swapi.dev/api/planets/2/"
          },
          {
              "name": "Naboo",
              "rotation_period": "26",
              "orbital_period": "312",
              "diameter": "12120",
              "climate": "temperate",
              "gravity": "1 standard",
              "terrain": "grassy hills, swamps, forests, mountains",
              "surface_water": "12",
              "population": "4500000000",
              "residents": [
                  "http://swapi.dev/api/people/3/",
                  "http://swapi.dev/api/people/21/",
                  "http://swapi.dev/api/people/35/",
                  "http://swapi.dev/api/people/36/",
                  "http://swapi.dev/api/people/37/",
                  "http://swapi.dev/api/people/38/",
                  "http://swapi.dev/api/people/39/",
                  "http://swapi.dev/api/people/42/",
                  "http://swapi.dev/api/people/60/",
                  "http://swapi.dev/api/people/61/",
                  "http://swapi.dev/api/people/66/"
              ],
              "films": [
                  "http://swapi.dev/api/films/3/",
                  "http://swapi.dev/api/films/4/",
                  "http://swapi.dev/api/films/5/",
                  "http://swapi.dev/api/films/6/"
              ],
              "created": "2014-12-10T11:52:31.066000Z",
              "edited": "2014-12-20T20:58:18.430000Z",
              "url": "http://swapi.dev/api/planets/8/"
          },
          {
              "name": "Coruscant",
              "rotation_period": "24",
              "orbital_period": "368",
              "diameter": "12240",
              "climate": "temperate",
              "gravity": "1 standard",
              "terrain": "cityscape, mountains",
              "surface_water": "unknown",
              "population": "1000000000000",
              "residents": [
                  "http://swapi.dev/api/people/34/",
                  "http://swapi.dev/api/people/55/",
                  "http://swapi.dev/api/people/74/"
              ],
              "films": [
                  "http://swapi.dev/api/films/3/",
                  "http://swapi.dev/api/films/4/",
                  "http://swapi.dev/api/films/5/",
                  "http://swapi.dev/api/films/6/"
              ],
              "created": "2014-12-10T11:54:13.921000Z",
              "edited": "2014-12-20T20:58:18.432000Z",
              "url": "http://swapi.dev/api/planets/9/"
          },
          {
              "name": "Dagobah",
              "rotation_period": "23",
              "orbital_period": "341",
              "diameter": "8900",
              "climate": "murky",
              "gravity": "N/A",
              "terrain": "swamp, jungles",
              "surface_water": "8",
              "population": "unknown",
              "residents": [],
              "films": [
                  "http://swapi.dev/api/films/2/",
                  "http://swapi.dev/api/films/3/",
                  "http://swapi.dev/api/films/6/"
              ],
              "created": "2014-12-10T11:42:22.590000Z",
              "edited": "2014-12-20T20:58:18.425000Z",
              "url": "http://swapi.dev/api/planets/5/"
          }
      ]);

    This separation is indicative of how our data may be grouped. Despite
    the separation, we can use the ``$unionWith`` stage to combine these two
    collections if we ever needed to analyze them as a single result set!

    Let‚Äôs say that we needed to find out the total population of planets,
    grouped by climate. Additionally, we‚Äôd like to leave out any planets
    that don‚Äôt have population data from our calculation. We can do this
    using an aggregation:

    .. code-block::

      // Run an aggregation to view total planet populations, grouped by climate type.
      use('union-walkthrough');

      db.lonely_planets.aggregate([
          {
              $match: {
                  population: { $ne: 'unknown' }
              }
          },
          { 
              $unionWith: { 
                  coll: 'popular_planets',
                  pipeline: [{
                      $match: {
                          population: { $ne: 'unknown' }
                      }
                  }] 
              } 
          },
          {
              $group: {
                  _id: '$climate', totalPopulation: { $sum: { $toLong: '$population' } }
              }
          }
      ]);

    If you‚Äôve followed along in your own MongoDB playground and have copied
    the code so far, try running the aggregation!

    And if you‚Äôre using the provided MongoDB playground I created, highlight
    lines 264 - 290 and then run the selected code.

    .. blockquote::

        üí° You‚Äôll notice in the code snippet above that I‚Äôve added another ``use('union-walkthrough');``
        method right above the aggregation code. I do this to make the
        selection of relevant code within the playground easier. It‚Äôs also
        required so that the aggregation code can run against the correct
        database. However, the same thing can be achieved by selecting
        multiple lines, namely the original ``use('union-walkthrough')`` line
        at the top and whatever additional example you‚Äôd like to run!

    You should see the results like so:

    .. code-block::

      [
        {
          _id: 'arid',
          totalPopulation: 200000
        },
        {
          _id: 'temperate',
          totalPopulation: 1007536000000
        },
        {
          _id: 'temperate, tropical',
          totalPopulation: 1000
        }
      ]

    Unsurprisingly, planets with ‚Äútemperate‚Äù climates seem to have more
    inhabitants. Something about that cool 75 F / 23.8 C, I guess‚Ä¶

    Let‚Äôs break down this aggregation:

    The first object we pass into our aggregation is also our first stage,
    used here as our filter criteria. Specifically, we use the `$match <https://docs.mongodb.com/manual/reference/operator/aggregation/match/>`__
    pipeline stage:

    .. code-block::

      {
          $match: {
              population: { $ne: 'unknown' }
          }
      },

    In this example, we filter out any documents that have ``unknown`` as
    their ``population`` value using the
    `$ne <https://docs.mongodb.com/manual/reference/operator/query/ne/>`__
    (not equal) operator.

    The next object (and next stage) in our aggregation is our
    ``$unionWith`` stage. Here, we specifiy what collection we‚Äôd like to
    perform a union with (including any duplicates). We also make use of the
    pipeline field to similarly filter out any documents in our
    ``popular_planets`` collection that have an unknown population:

    .. code-block::

      { 
          $unionWith: { 
              coll: 'popular_planets',
              pipeline: [
                  {
                      $match: {
                          population: { $ne: 'unknown' }
                      }
                  }
              ] 
          } 
      },

    Finally, we have our last stage in our aggregation. After combining our
    ``lonely_planets`` and ``popular_planets`` collections (both filtering
    out documents with no population data), we group the resulting documents
    using a `$group <https://docs.mongodb.com/manual/reference/operator/aggregation/group/>`__ stage:

    .. code-block::

      {
          $group: {
              _id: '$climate', 
              totalPopulation: { $sum: { $toLong: '$population' } }
          }
      }

    Since we want to know the total population per climate type, we first
    specify ``_id`` to be the ``$climate`` field from our combined
    result set. Then, we calculate a new field called ``totalPopulation`` by
    using a
    `$sum <https://docs.mongodb.com/manual/reference/operator/aggregation/sum/>`__
    operator to add each matching document‚Äôs population values together.
    You‚Äôll also notice that based on the data we have, we needed to use a
    `$toLong <https://docs.mongodb.com/manual/reference/operator/aggregation/toLong/>`__
    operator to first convert our ``$population`` field into a calculable
    value!

    ``$unionWith`` without a pipeline
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    .. blockquote::

        üìÉ Use `this <https://github.com/adriennetacke/mdb-union-all-walkthrough/blob/master/unionWith_examples_similar_schemas.mongodb>`__ playground if
        you‚Äôd like follow along with pre-written code for this example.

    Now, if you *don‚Äôt* need to run some additional processing on the
    collection you‚Äôre combining with, you don‚Äôt have to! The ``pipeline``
    field is optional and is only there if you need it.

    So, if you just need to work with the planet data as a unified set, you can
    do that too:

    .. code-block::

      // Run an aggregation with no pipeline
      use('union-walkthrough');

      db.lonely_planets.aggregate([
          { $unionWith: 'popular_planets' }
      ]);

    Copy this aggregation into your own playground and run it!
    Alternatively, select and run lines 293 - 297 if using the provided
    MongoDB playground!

    Tada! Now you can use this unified dataset for analysis or further
    processing.

    Different Schemas
    ~~~~~~~~~~~~~~~~~

    Combining the same schemas is great, but we can do
    that in regular SQL too! The real convenience of the ``$unionWith``
    pipeline stage is that it can also combine collections with different
    schemas. Let‚Äôs take a look!

    ``$unionWith`` using collections with different schemas
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    .. blockquote::

        üìÉ Use `this <https://github.com/adriennetacke/mdb-union-all-walkthrough/blob/master/unionWith_examples_different_schemas.mongodb>`__ playground if
        you‚Äôd like follow along with pre-written code for this example.

    As before, we‚Äôll specifiy the database we want to use:

    .. code-block::

      use('union-walkthrough');

    This time, we'll use some acquired information about certain starships and
    vehicles that are used in this same movie series. Let‚Äôs add them to
    their respective collections:

    .. code-block::

      // Insert a few documents into the starships collection
      db.starships.insertMany([
          {
              "name": "Death Star",
              "model": "DS-1 Orbital Battle Station",
              "manufacturer": "Imperial Department of Military Research, Sienar Fleet Systems",
              "cost_in_credits": "1000000000000",
              "length": "120000",
              "max_atmosphering_speed": "n/a",
              "crew": 342953,
              "passengers": 843342,
              "cargo_capacity": "1000000000000",
              "consumables": "3 years",
              "hyperdrive_rating": 4.0,
              "MGLT": 10,
              "starship_class": "Deep Space Mobile Battlestation",
              "pilots": []
          },
          {
              "name": "Millennium Falcon",
              "model": "YT-1300 light freighter",
              "manufacturer": "Corellian Engineering Corporation",
              "cost_in_credits": "100000",
              "length": "34.37",
              "max_atmosphering_speed": "1050",
              "crew": 4,
              "passengers": 6,
              "cargo_capacity": 100000,
              "consumables": "2 months",
              "hyperdrive_rating": 0.5,
              "MGLT": 75,
              "starship_class": "Light freighter",
              "pilots": [
                  "http://swapi.dev/api/people/13/",
                  "http://swapi.dev/api/people/14/",
                  "http://swapi.dev/api/people/25/",
                  "http://swapi.dev/api/people/31/"
              ]
          },
          {
              "name": "Y-wing",
              "model": "BTL Y-wing",
              "manufacturer": "Koensayr Manufacturing",
              "cost_in_credits": "134999",
              "length": "14",
              "max_atmosphering_speed": "1000km",
              "crew": 2,
              "passengers": 0,
              "cargo_capacity": 110,
              "consumables": "1 week",
              "hyperdrive_rating": 1.0,
              "MGLT": 80,
              "starship_class": "assault starfighter",
              "pilots": []
          },
          {
              "name": "X-wing",
              "model": "T-65 X-wing",
              "manufacturer": "Incom Corporation",
              "cost_in_credits": "149999",
              "length": "12.5",
              "max_atmosphering_speed": "1050",
              "crew": 1,
              "passengers": 0,
              "cargo_capacity": 110,
              "consumables": "1 week",
              "hyperdrive_rating": 1.0,
              "MGLT": 100,
              "starship_class": "Starfighter",
              "pilots": [
                  "http://swapi.dev/api/people/1/",
                  "http://swapi.dev/api/people/9/",
                  "http://swapi.dev/api/people/18/",
                  "http://swapi.dev/api/people/19/"
              ]
          },
      ]);

      // Insert a few documents into the vehicles collection
      db.vehicles.insertMany([
          {
              "name": "Sand Crawler",
              "model": "Digger Crawler",
              "manufacturer": "Corellia Mining Corporation",
              "cost_in_credits": "150000",
              "length": "36.8 ",
              "max_atmosphering_speed": 30,
              "crew": 46,
              "passengers": 30,
              "cargo_capacity": 50000,
              "consumables": "2 months",
              "vehicle_class": "wheeled",
              "pilots": []
          },
          {
              "name": "X-34 landspeeder",
              "model": "X-34 landspeeder",
              "manufacturer": "SoroSuub Corporation",
              "cost_in_credits": "10550",
              "length": "3.4 ",
              "max_atmosphering_speed": 250,
              "crew": 1,
              "passengers": 1,
              "cargo_capacity": 5,
              "consumables": "unknown",
              "vehicle_class": "repulsorcraft",
              "pilots": [],
          },
          {
              "name": "AT-AT",
              "model": "All Terrain Armored Transport",
              "manufacturer": "Kuat Drive Yards, Imperial Department of Military Research",
              "cost_in_credits": "unknown",
              "length": "20",
              "max_atmosphering_speed": 60,
              "crew": 5,
              "passengers": 40,
              "cargo_capacity": 1000,
              "consumables": "unknown",
              "vehicle_class": "assault walker",
              "pilots": [],
              "films": [
                  "http://swapi.dev/api/films/2/",
                  "http://swapi.dev/api/films/3/"
              ],
              "created": "2014-12-15T12:38:25.937000Z",
              "edited": "2014-12-20T21:30:21.677000Z",
              "url": "http://swapi.dev/api/vehicles/18/"
          },
          {
              "name": "AT-ST",
              "model": "All Terrain Scout Transport",
              "manufacturer": "Kuat Drive Yards, Imperial Department of Military Research",
              "cost_in_credits": "unknown",
              "length": "2",
              "max_atmosphering_speed": 90,
              "crew": 2,
              "passengers": 0,
              "cargo_capacity": 200,
              "consumables": "none",
              "vehicle_class": "walker",
              "pilots": [
                  "http://swapi.dev/api/people/13/"
              ]
          },
          {
              "name": "Storm IV Twin-Pod cloud car",
              "model": "Storm IV Twin-Pod",
              "manufacturer": "Bespin Motors",
              "cost_in_credits": "75000",
              "length": "7",
              "max_atmosphering_speed": 1500,
              "crew": 2,
              "passengers": 0,
              "cargo_capacity": 10,
              "consumables": "1 day",
              "vehicle_class": "repulsorcraft",
              "pilots": [],
          }
      ]);

    You may be thinking (as I first did), what‚Äôs the difference between
    starships and vehicles? You‚Äôll be pleased to know that starships are
    defined as any "single transport craft that has hyperdrive capability".
    Any other single transport craft that **does not have** hyperdrive
    capability is considered a vehicle. The more you know‚Ä¶

    If you look at the two collections, you‚Äôll see that they have two key
    differences:

    -  The ``max_atmosphering_speed`` field is present in both collections, but is a ``string`` in the ``starships`` collection and an ``int`` in the ``vehicles`` collection.
    -  The ``starships`` collection has two fields (``hyperdrive_rating``, ``MGLT``) that are not present in the ``vehicles`` collection, as it only relates to starships.

    But you know what? That‚Äôs not a problem for the ``$unionWith`` stage!
    You can combine them just as before:

    .. code-block::

      // Run an aggregation with no pipeline and differing schemas
      use('union-walkthrough');

      db.starships.aggregate([
        { $unionWith: 'vehicles' }
      ]);

    Try running the aggregation in your playground! Or if you‚Äôre following
    along in the MongoDB playground I‚Äôve provided, select and run lines 185
    - 189! You should get the following combined result set as your output:

    .. code-block::

      [
        {
          _id: 5f306ddca3ee8339643f137e,
          name: 'Death Star',
          model: 'DS-1 Orbital Battle Station',
          manufacturer: 'Imperial Department of Military Research, Sienar Fleet Systems',
          cost_in_credits: '1000000000000',
          length: '120000',
          max_atmosphering_speed: 'n/a',
          crew: 342953,
          passengers: 843342,
          cargo_capacity: '1000000000000',
          consumables: '3 years',
          hyperdrive_rating: 4,
          MGLT: 10,
          starship_class: 'Deep Space Mobile Battlestation',
          pilots: []
        },
        {
          _id: 5f306ddca3ee8339643f137f,
          name: 'Millennium Falcon',
          model: 'YT-1300 light freighter',
          manufacturer: 'Corellian Engineering Corporation',
          cost_in_credits: '100000',
          length: '34.37',
          max_atmosphering_speed: '1050',
          crew: 4,
          passengers: 6,
          cargo_capacity: 100000,
          consumables: '2 months',
          hyperdrive_rating: 0.5,
          MGLT: 75,
          starship_class: 'Light freighter',
          pilots: [
            'http://swapi.dev/api/people/13/',
            'http://swapi.dev/api/people/14/',
            'http://swapi.dev/api/people/25/',
            'http://swapi.dev/api/people/31/'
          ]
        },
        // + 7 other results, omitted for brevity
      ]

    Can you imagine doing that in SQL? Hint: You can‚Äôt! That kind of schema
    restriction is something you don‚Äôt need to worry about with MongoDB,
    though!

    $unionWith using collections with different schemas and a pipeline
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    .. blockquote::

        üìÉ Use `this <https://github.com/adriennetacke/mdb-union-all-walkthrough/blob/master/unionWith_examples_different_schemas.mongodb>`__ playground if
        you‚Äôd like follow along with pre-written code for this example.

    So we can combine different schemas no problem. What if we need to do a
    little extra work on our collection before combining it? That‚Äôs where
    the ``pipeline`` field comes in!

    Let‚Äôs say that there‚Äôs some classified information in our data about the
    vehicles. Namely, any vehicles manufactured by Kuat Drive Yards (AKA a division of the
    Imperial Department of Military Research).

    By direct orders, you are instructed not to give out this information
    under any circumstances. In fact, you need to intercept any
    requests for vehicle information and remove these classified vehicles from the
    list!

    We can do that like so:

    .. code-block::

      use('union-walkthrough');

      db.starships.aggregate([
          { 
              $unionWith: {
                  coll: 'vehicles',
                  pipeline: [
                      { 
                          $redact: {
                              $cond: {
                                  if: { $eq: [ "$manufacturer", "Kuat Drive Yards, Imperial Department of Military Research"] },
                                  then: "$$PRUNE",
                                  else: "$$DESCEND"
                              }
                          }
                      }
                  ]
              }
          }
      ]);

    In this example, we‚Äôre combining the ``starships`` and ``vehicles``
    collections as before, using the ``$unionWith`` pipeline stage. We
    also process the ``vehicle`` data a bit more, using the ``$unionWith``'s optional ``pipeline`` field:

    .. code-block::

      // Pipeline used with the vehicle collection
      { 
          $redact: {
              $cond: {
                  if: { $eq: [ "$manufacturer", "Kuat Drive Yards, Imperial Department of Military Research"] },
                  then: "$$PRUNE",
                  else: "$$DESCEND"
              }
          }
      }
      ...

    Inside the ``$unionWith``‚Äôs pipeline, we use a
    `$redact <https://docs.mongodb.com/manual/reference/operator/aggregation/redact/>`__
    stage to restrict the contents of our documents based on a condition. The condition is specified using the
    `$cond <https://docs.mongodb.com/manual/reference/operator/aggregation/cond/>`__
    operator, which acts like an ``if/else`` statement.

    In our case, we are evaluating whether or not the ``manufacturer`` field holds a value of
    ‚ÄúKuat Drive Yards, Imperial Department of Military Research‚Äù. If it does
    (uh oh, that‚Äôs classified!), we use a system variable called
    `$$PRUNE <https://docs.mongodb.com/manual/reference/operator/aggregation/redact/#prune>`__, which lets us exclude all fields at the current
    document/embedded document level. If it doesn‚Äôt, we use another system
    variable called `$$DESCEND <https://docs.mongodb.com/manual/reference/operator/aggregation/redact/#descend>`__, which will return all fields at the
    current document level, except for any embedded documents.

    This works perfectly for our use case. Try running the aggregation
    (lines 192 - 211, if using the provided MongoDB Playground). You should
    see a combined result set, minus any Imperial manufactured vehicles:

    .. code-block::

      [
        {
          _id: 5f306ddca3ee8339643f137e,
          name: 'Death Star',
          model: 'DS-1 Orbital Battle Station',
          manufacturer: 'Imperial Department of Military Research, Sienar Fleet Systems',
          cost_in_credits: '1000000000000',
          length: '120000',
          max_atmosphering_speed: 'n/a',
          crew: 342953,
          passengers: 843342,
          cargo_capacity: '1000000000000',
          consumables: '3 years',
          hyperdrive_rating: 4,
          MGLT: 10,
          starship_class: 'Deep Space Mobile Battlestation',
          pilots: []
        },
        {
          _id: 5f306ddda3ee8339643f1383,
          name: 'X-34 landspeeder',
          model: 'X-34 landspeeder',
          manufacturer: 'SoroSuub Corporation',
          cost_in_credits: '10550',
          length: '3.4 ',
          max_atmosphering_speed: 250,
          crew: 1,
          passengers: 1,
          cargo_capacity: 5,
          consumables: 'unknown',
          vehicle_class: 'repulsorcraft',
          pilots: []
        },
        // + 5 more non-Imperial manufactured results, omitted for brevity
      ]

    We did our part to restrict classified information! üé∂ *Hums Imperial
    March* üé∂

    Restrictions for UNION ALL
    --------------------------

    Now that we know how the ``$unionWith`` stage works, it‚Äôs important to
    discuss its limits and restrictions.

    Duplicates
    ~~~~~~~~~~

    We‚Äôve mentioned it already, but it‚Äôs important to reiterate: using the
    ``$unionWith`` stage will give you a combined result set which may
    include duplicates! This is equivalent to how the ``UNION ALL`` operator
    works in ``SQL`` as well. As a workaround, using a ``$group`` stage at the
    end of your pipeline to remove duplicates is advised, but only when possible
    and if the resulting data does not get inaccurately skewed.

    There are plans to add similar fuctionality to
    ``UNION`` (which combines result sets but *removes* duplicates), but
    that may be in a future release.

    Sharded Collections
    ~~~~~~~~~~~~~~~~~~~

    If you use a ``$unionWith`` stage as part of a
    `$lookup <https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#lookup-join-pipeline>`__
    pipeline, the collection you specify for the ``$unionWith`` cannot be
    sharded. As an example, take a look at this aggregation:

    .. code-block::

      // Invalid aggregation (tried to use sharded collection with $unionWith)
      db.lonely_planets.aggregate([
          {
            $lookup: {
                from: "extinct_planets",
                let: { last_known_population: "$population", years_extinct: "$time_extinct" },
                pipeline: [
                  ...
                  { $unionWith: { coll: "questionable_planets", pipeline: [ ... ] } },
                  ...
                ],
                as: "planetdata"
            }
          }
      ])

    The coll ``questionable_planets`` (located within the ``$unionWith`` stage) cannot be sharded.
    This is enforced to prevent
    a significant decrease in performance due to the shuffling of data
    around the cluster as it determines the best execution plan.

    Transactions
    ~~~~~~~~~~~~

    Aggregation pipelines can‚Äôt use the ``$unionWith`` stage inside
    transactions because a rare, but possible 3-thread deadlock can occur in very
    niche scenarios. Additionally, in MongoDB 4.4, there is a first-time
    definition of a view that would restrict its reading from within a
    transaction.

    ``$out`` and ``$merge``
    ~~~~~~~~~~~~~~~~~~~~~~~

    The
    `$out <https://docs.mongodb.com/manual/reference/operator/aggregation/out/#pipe._S_out>`__
    and
    `$merge <https://docs.mongodb.com/manual/reference/operator/aggregation/merge/#pipe._S_merge>`__
    stages cannot be used in a ``$unionWith`` pipeline. Since both ``$out`` and ``$merge`` are
    stages that *write* data to a collection, they need to be the *last* stage in
    a pipeline. This conflicts with the usage of the ``$unionWith`` stage
    as it outputs its combined result set onto the next stage, which
    can be used at any point in an aggregation pipeline.

    Collations
    ~~~~~~~~~~

    If your aggregation includes a
    `collation <https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/#method-collection-aggregate-collation>`__,
    that collation is used for the operation, ignoring any other collations.

    However, if your aggregation doesn‚Äôt include a collation, it will use
    the collation for the top-level collection/view on which the aggregation
    is run:

    -  If the ``$unionWith`` coll is a collection, its collation is ignored.
    -  If the ``$unionWith`` coll is a view, then its collation must match that of the top-level collection/view. Otherwise, the operation errors.

.. summary::

   You've made it to the end!
   ----------

    We've discussed what the ``$unionWith`` pipeline stage is and how you can 
    use it in your aggregations to combine data from multiple collections.
    Though similar to SQL's ``UNION ALL`` operation, MongoDB's ``$unionWith`` stage distinguishes itself
    through some convenient and much-needed characteristics. Most notable is the ability to combine
    collections with different schemas! And as a much needed improvement, using a ``$unionWith`` stage
    eliminates the need to write additional code, code that was required because we had no other way to
    combine our data!

    If you have any questions about the ``$unionWith`` pipeline stage or this blog post,
    head over to the `MongoDB Community forums <https://developer.mongodb.com/community/forums/>`__
    or `Tweet me <https://twitter.com/adriennetacke>`__!

   .. include:: /includes/callouts/safe-harbor.rst

